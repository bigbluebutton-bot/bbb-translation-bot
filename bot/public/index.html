<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>BBB Bot Control</title>
  <style>
    /* Keep language list neat, scrollable, and remember scroll pos */
    .lang-container {
      max-height: 150px; /* adjust as needed */
      overflow-y: auto;
    }
    .lang-container label {
      display: block;
      white-space: nowrap;
    }
  </style>
</head>
<body>
  <h1 id="botCount">Bots: 0 / 0</h1>

  <table id="meetingsTable" border="1" cellspacing="0" cellpadding="4">
    <thead>
      <tr>
        <th>Meeting</th>
        <th>Bot</th>
        <th>Task</th>
        <th>Languages</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <script>
  const API_BASE = '/api/v1';
  let languagesMap = {};      // code -> full name
  let botsByMeeting = {};     // meeting_id -> bot
  let maxBots = 0;
  let currentBots = 0;

  // Remember scroll positions of each language list keyed by meetingID
  const langScroll = {};      // meeting_id -> scrollTop

  // --------------------------------------------------
  // Helper wrappers
  // --------------------------------------------------
  async function getJSON(url, opts) {
    try {
      const res = await fetch(url, opts);
      if (!res.ok) throw new Error(res.statusText);
      if (res.status === 204) return null;
      return await res.json();
    } catch (err) {
      console.error(url, err);
      return null;
    }
  }

  const put  = (u) => getJSON(u, {method:'PUT' });
  const post = (u) => getJSON(u, {method:'POST'});
  const del  = (u) => getJSON(u, {method:'DELETE'});

  // --------------------------------------------------
  // Initial static data
  // --------------------------------------------------
  async function fetchLanguages() {
    const data = await getJSON(`${API_BASE}/bbb/languages`);
    if (data) languagesMap = data;
  }

  // --------------------------------------------------
  // Status / Bots / Meetings
  // --------------------------------------------------
  async function fetchStatus() {
    const data = await getJSON(`${API_BASE}/status`);
    if (!data) return;
    currentBots = data.bots_count;
    maxBots     = data.max_bots;
    document.getElementById('botCount').textContent = `Bots: ${currentBots} / ${maxBots}`;
  }

  async function fetchBots() {
    const data = await getJSON(`${API_BASE}/bots`);
    botsByMeeting = {};
    if (!data) return;
    Object.values(data).forEach(b => botsByMeeting[b.meeting_id] = b);
  }

  // --------------------------------------------------
  // Utility: convert server task value to string name and back
  // --------------------------------------------------
  function taskName(bot) {
    if (!bot) return 'transcribe';
    if (typeof bot.task === 'string') return bot.task;             // already a name
    return bot.task === 1 ? 'translate' : 'transcribe';            // numeric convention
  }
  function taskValue(name) {
    if (typeof botsByMeeting.__numericTaskExample === 'string') return name; // string API
    return name === 'translate' ? 1 : 0;                         // numeric API
  }

  // --------------------------------------------------
  // UI helpers
  // --------------------------------------------------
  function buildLanguageCheckboxes(meetingID, selectedCodes, disabled, onChange) {
    const container = document.createElement('div');
    container.className = 'lang-container';
    container.dataset.meeting = meetingID;

    // restore scroll position if known
    if (langScroll[meetingID] !== undefined) {
      container.scrollTop = langScroll[meetingID];
    }

    // persist scroll position when user scrolls
    container.addEventListener('scroll', () => {
      langScroll[meetingID] = container.scrollTop;
    });

    // event handler to compute chosen languages and notify parent
    const changed = () => {
      const chosen = Array.from(container.querySelectorAll('input[type=checkbox]'))
        .filter(cb => cb.checked)
        .map(cb => cb.value);
      onChange(chosen);
    };

    // Build each checkbox
    for (const [code, name] of Object.entries(languagesMap)) {
      const label = document.createElement('label');
      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.value = code;
      cb.checked = selectedCodes && selectedCodes.includes(code);
      cb.disabled = disabled;
      cb.addEventListener('change', changed);

      label.appendChild(cb);
      label.appendChild(document.createTextNode(' ' + name));
      container.appendChild(label);
    }
    return container;
  }

  function createTaskToggle(initialTask, onToggle) {
    const label = document.createElement('label');
    const cb    = document.createElement('input');
    const text  = document.createElement('span');
    cb.type = 'checkbox';
    cb.checked = initialTask === 'translate';
    text.textContent = initialTask.charAt(0).toUpperCase() + initialTask.slice(1);

    cb.addEventListener('change', () => {
      const newTask = cb.checked ? 'translate' : 'transcribe';
      text.textContent = newTask.charAt(0).toUpperCase() + newTask.slice(1);
      onToggle(newTask);
    });

    label.appendChild(cb);
    label.appendChild(text);
    return label;
  }

  // --------------------------------------------------
  // Main table renderer
  // --------------------------------------------------
  async function drawMeetings() {
    const meetings = (await getJSON(`${API_BASE}/bbb/meetings`)) || [];
    const tbody = document.querySelector('#meetingsTable tbody');

    // capture current scroll positions before wiping table
    tbody.querySelectorAll('.lang-container').forEach(div => {
      if (div.dataset.meeting)
        langScroll[div.dataset.meeting] = div.scrollTop;
    });

    tbody.innerHTML = '';

    meetings.filter(m => m.running).forEach(m => {
      const tr = document.createElement('tr');

      // Meeting column
      const tdName = document.createElement('td');
      tdName.textContent = m.meetingName || m.meetingID;
      tr.appendChild(tdName);

      // Join / Leave button
      const tdBtn = document.createElement('td');
      const bot   = botsByMeeting[m.meetingID];
      const btn   = document.createElement('button');
      btn.textContent = bot ? 'Leave' : 'Join';
      btn.disabled    = !bot && currentBots >= maxBots;
      tdBtn.appendChild(btn);
      tr.appendChild(tdBtn);

      // Task toggle & Language selector share state
      const currentTask = taskName(bot);
      const tdTask = document.createElement('td');
      const tdLang = document.createElement('td');

      // Language checkbox list (built first so toggle callback can access)
      const langBox = buildLanguageCheckboxes(
        m.meetingID,
        bot ? bot.languages : [],
        currentTask === 'transcribe',
        async (selection) => {
          const currentBot = botsByMeeting[m.meetingID];
          if (!currentBot) return;

          // Work with sets for reliable diffing
          const activeSet = new Set(currentBot.languages || []);
          const chosenSet = new Set(selection);

          const toAdd    = [...chosenSet].filter(l => !activeSet.has(l));
          const toRemove = [...activeSet].filter(l => !chosenSet.has(l));

          for (const lang of toAdd) {
            await put(`${API_BASE}/bot/${encodeURIComponent(currentBot.id)}/translate/${lang}`);
            activeSet.add(lang); // keep local in sync until refresh
          }
          for (const lang of toRemove) {
            await del(`${API_BASE}/bot/${encodeURIComponent(currentBot.id)}/translate/${lang}`);
            activeSet.delete(lang);
          }

          // update cached list immediately so consecutive edits work without waiting for refresh
          currentBot.languages = [...activeSet];

          await fetchBots();
          drawMeetings();
        }
      );

      // Task toggle
      const toggle = createTaskToggle(currentTask, async (newTask) => {
        const currentBot = botsByMeeting[m.meetingID];
        if (!currentBot) return;
        // optimistic UI update
        currentBot.task = taskValue(newTask);

        // Enable/disable language checkboxes depending on task
        Array.from(langBox.querySelectorAll('input[type=checkbox]')).forEach(cb => cb.disabled = newTask === 'transcribe');

        await put(`${API_BASE}/bot/${encodeURIComponent(currentBot.id)}/task/${newTask}`);
        await fetchBots();
        drawMeetings();
      });

      tdTask.appendChild(toggle);
      tdLang.appendChild(langBox);
      tr.appendChild(tdTask);
      tr.appendChild(tdLang);

      // Join/Leave logic handler after building rest of row so we can refresh gracefully
      btn.addEventListener('click', async () => {
        if (bot) {
          await post(`${API_BASE}/bot/${encodeURIComponent(bot.id)}/leave`);
        } else {
          await post(`${API_BASE}/bot/join/${encodeURIComponent(m.meetingID)}`);
        }
        await refresh();
      });

      tbody.appendChild(tr);
    });
  }

  // --------------------------------------------------
  // Periodic refresh
  // --------------------------------------------------
  async function refresh() {
    await Promise.all([fetchStatus(), fetchBots()]);
    drawMeetings();
  }

  (async () => {
    await fetchLanguages();
    await refresh();
    setInterval(refresh, 2000);
  })();
  </script>
</body>
</html>
